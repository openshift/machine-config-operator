package mco

import (
	"fmt"

	o "github.com/onsi/gomega"

	exutil "github.com/openshift/machine-config-operator/ginkgo-test/test/extended/util"
	logger "github.com/openshift/machine-config-operator/ginkgo-test/test/extended/util/logext"
)

// ContainerRuntimeConfig struct is used to handle ContainerRuntimeConfig resources in OCP
type ContainerRuntimeConfig struct {
	Resource
	template string
}

// ContainerRuntimeConfigList handles list of nodes
type ContainerRuntimeConfigList struct {
	ResourceList
}

// NewContainerRuntimeConfig creates a ContainerRuntimeConfig struct
func NewContainerRuntimeConfig(oc *exutil.CLI, name, template string) *ContainerRuntimeConfig {
	return &ContainerRuntimeConfig{Resource: *NewResource(oc, "ContainerRuntimeConfig", name), template: template}
}

// NewContainerRuntimeConfigList create a NewKubeletConfigList struct
func NewContainerRuntimeConfigList(oc *exutil.CLI) *ContainerRuntimeConfigList {
	return &ContainerRuntimeConfigList{*NewResourceList(oc, "ContainerRuntimeConfig")}
}

// TODO: Refactor this strutc remove this method and embed Template
func (cr *ContainerRuntimeConfig) create(parameters ...string) {
	allParams := []string{"--ignore-unknown-parameters=true", "-f", cr.template,
		"-p", "NAME=" + cr.name}
	allParams = append(allParams, parameters...)
	exutil.CreateClusterResourceFromTemplate(cr.oc, allParams...)
}

func (cr ContainerRuntimeConfig) waitUntilSuccess(timeout string) {
	logger.Infof("wait for %s to report success", cr.name)
	o.Eventually(func() map[string]interface{} {
		successCond := JSON(cr.GetConditionByType("Success"))
		if successCond.Exists() {
			return successCond.ToMap()
		}
		logger.Infof("success condition not found, conditions are %s", cr.GetOrFail(`{.status.conditions}`))
		return nil
	},
		timeout, "2s").Should(o.SatisfyAll(o.HaveKeyWithValue("status", "True"),
		o.HaveKeyWithValue("message", "Success")))
}

func (cr ContainerRuntimeConfig) waitUntilFailure(expectedMsg, timeout string) {
	logger.Infof("wait for %s to report failure", cr.name)
	o.Eventually(func() map[string]interface{} {
		failureCond := JSON(cr.GetConditionByType("Failure"))
		if failureCond.Exists() {
			return failureCond.ToMap()
		}
		logger.Infof("Failure condition not found, conditions are %s", cr.GetOrFail(`{.status.conditions}`))
		return nil
	},
		timeout, "2s").Should(o.SatisfyAll(o.HaveKeyWithValue("status", "False"), o.HaveKeyWithValue("message", o.ContainSubstring(expectedMsg))))
}

// GetGeneratedMCName returns the name of the MC that was generated by this ContainerRuntimeConfig resource
func (cr ContainerRuntimeConfig) GetGeneratedMCName() (string, error) {
	mcName, err := cr.Get(`{.metadata.finalizers[0]}`)
	if err != nil {
		return "", err
	}
	if mcName == "" {
		return "", fmt.Errorf("It was not possible to get the finalizer from %s %s: %s", cr.GetKind(), cr.GetName(), cr.PrettyString())
	}
	return mcName, nil
}

// GetGeneratedMCName returns the name of the MC that was generated by this ContainerRuntimeConfig resource and fails the test case if it cannot be done
func (cr ContainerRuntimeConfig) GetGeneratedMCNameOrFail() string {
	mcName, err := cr.GetGeneratedMCName()
	o.Expect(err).NotTo(o.HaveOccurred(), "Error getting the generated MC for %s %s", cr.GetKind(), cr.GetName())
	return mcName
}
