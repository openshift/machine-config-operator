package render

import (
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"

	baseutil "github.com/coreos/butane/base/util"
	"github.com/coreos/ignition/v2/config/util"
	ign3types "github.com/coreos/ignition/v2/config/v3_2/types"
	mcSpecv1 "github.com/openshift/machine-config-operator/pkg/apis/machineconfiguration.openshift.io/v1"
	ctrlcommon "github.com/openshift/machine-config-operator/pkg/controller/common"
	"github.com/openshift/machine-config-operator/test/helpers"

	"gopkg.in/yaml.v3"
)

const MCDContentPath = "/etc/machine-config-daemon/mcd_content.json"

type MCDContent struct {
	KernelArguments []string `json:"kernelArguments"`
	FIPS            bool     `json:"fips"`
}

func MachineConfigToIgnition(mcSpec *mcSpecv1.MachineConfigSpec) (ign3types.Config, error) {
	// Config
	ignition, err := ctrlcommon.ParseAndConvertConfig(mcSpec.Config.Raw)
	if err != nil {
		return ign3types.Config{}, fmt.Errorf("parsing Ignition config failed: %w", err)
	}

	var treeFile TreeFile
	// Extensions
	supportedExtensions := ctrlcommon.GetSupportedExtensions()
	for _, mcSpecExtension := range mcSpec.Extensions {
		treeFile.Packages = append(treeFile.Packages, supportedExtensions[mcSpecExtension]...)
	}

	// KernelType
	switch kernelType := ctrlcommon.CanonicalizeKernelType(mcSpec.KernelType); kernelType {
	case ctrlcommon.KernelTypeDefault:
		// no-op
	case ctrlcommon.KernelTypeRealtime:
		treeFile.Packages = append(treeFile.Packages, "kernel-rt", "kernel-rt-modules", "kernel-rt-modules-extra")
		treeFile.OverrideRemove = append(treeFile.OverrideRemove, "kernel", "kernel-modules", "kernel-modules-extra")
	default:
		return ign3types.Config{}, fmt.Errorf("unsupported kernel type %s", kernelType)
	}

	// add content from Extensions and KernelType to ignition
	if !treeFile.isEmpty() {
		ignitionOriginFile, err := treeFile.toIgnFile(false)
		if err != nil {
			return ign3types.Config{}, fmt.Errorf("could not convert OriginFile to Ignition file: %w", err)
		}
		ignition.Storage.Files = append(ignition.Storage.Files, ignitionOriginFile)
	}

	// KernelArguments and FIPS
	mcdContent, err := json.Marshal(&MCDContent{
		KernelArguments: mcSpec.KernelArguments,
		FIPS:            mcSpec.FIPS,
	})
	if err != nil {
		return ign3types.Config{}, fmt.Errorf("couldn't marshal MCD content: %w", err)
	}
	ignition.Storage.Files = append(ignition.Storage.Files, helpers.NewIgnFile(MCDContentPath, string(mcdContent)))

	return ignition, nil
}

type TreeFile struct {
	Packages       []string `yaml:"packages,omitempty"`
	OverrideRemove []string `yaml:"override-remove,omitempty"`
}

func (treeFile TreeFile) isEmpty() bool {
	return len(treeFile.Packages) == 0 && len(treeFile.OverrideRemove) == 0
}

func (treeFile TreeFile) toIgnFile(allowCompression bool) (ign3types.File, error) {
	treeFileContents, err := yaml.Marshal(treeFile)
	if err != nil {
		return ign3types.File{}, fmt.Errorf("failed to marshal extensions as yaml: %w", err)
	}
	fullYamlContents := append([]byte("# Generated by the MCO\n\n"), treeFileContents...)
	src, gzipped, err := baseutil.MakeDataURL(fullYamlContents, nil, allowCompression)
	if err != nil {
		return ign3types.File{}, fmt.Errorf("could not encode extensions file: %w", err)
	}
	hash := sha256.New()
	hash.Write([]byte(src))
	sha := hex.EncodeToString(hash.Sum(nil))[0:7]
	mode := 0644
	file := ign3types.File{
		Node: ign3types.Node{
			Path: "/etc/rpm-ostree/origin.d/extensions-" + sha + ".yaml",
		},
		FileEmbedded1: ign3types.FileEmbedded1{
			Contents: ign3types.Resource{
				Source: util.StrToPtr(src),
			},
			Mode: &mode,
		},
	}
	if gzipped {
		file.Contents.Compression = util.StrToPtr("gzip")
	}

	return file, nil
}
